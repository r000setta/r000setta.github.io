---
layout:     post   				    # 使用的布局（不需要改）
title:      JDK8 JUC阅读(3)			# 标题 
subtitle:   "锁"          #副标题
date:       2020-1-10			# 时间
author:     Jqy					# 作者
header-img: img/wallhaven-oxw2mp.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Java
    - 源码阅读
    - JUC
---

## LockSupport
工具类，主要作用是挂起，唤醒线程，为创建锁和其他同步类的基础。基于Unsafe实现

## 抽象同步队列AQS
实现同步器的基本组件，锁的底层使用AQS实现。
AQS本质是一个FIFO双端队列，队列类型为内部类Node

AQS维持了一个单一的状态信息state，对于ReentarantLock，state表示当前线程获取锁的可重入次数；对于读写锁，高16位表示读状态(获取锁的次数)，低16位表示获取到写锁的线程的可重入次数；对于semaphore，state表示可用信号的个数；对于CountDownLatch，state表示计数器当前的值。
内部类ConditionObject，用来结合锁实现线程同步。
线程同步的关键是对state的操作，操作state分为独占和共享两种方式。
独占方式下，获取释放资源过程如下
```java
public final void acquire(int arg) {
        if (!tryAcquire(arg) &&     //尝试获取资源，成功则返回
        //失败将当前线程封装为Node.EXCLUSIVE类型后插入到AQS尾部，
        //并通过LockSupport.pack(this)挂起自己
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

public final boolean release(int arg) {
        if (tryRelease(arg)) {  //尝试释放资源
            Node h = head;
            if (h != null && h.waitStatus != 0)
            //通过LockSupport.unpack(thread)方式激活AQS队列队首线程
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
```
其中tryAcquire,tryRelease0只是提供了一个基础框架，需要结合情景进行定制

共享方式下，获取释放资源过程如下：
```java
public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)  //尝试获取资源，成功则直接返回
        //失败将当前线程封装为Node.SHARED类型后插入到AQS尾部，
        //并通过LockSupport.pack(this)挂起自己
            doAcquireShared(arg);
    }

public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
```

### AQS内部的队列
以入队操作为例,当一个线程获取锁失败后，线程会转化为Node节点，入队至AQS阻塞队列
```java
private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

### ConditionObject
AQS内部类，可以访问AQS内部的变量，每个条件变量内部维护了一个条件队列，存放调用条件变量await方法时被阻塞的线程(该队列不是AQS队列)
```java
public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            //创建新Node节点并入队列尾部
            Node node = addConditionWaiter();
            //释放当前线程取得的锁
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            while (!isOnSyncQueue(node)) {
                //通过park挂起线程
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }

public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
            //将队头元素移动至AQS
                doSignal(first);
        }
```

一个锁对应一个AQS阻塞队列，对应多个条件变量，每个条件变量有自己的一个条件队列。

## 独占锁